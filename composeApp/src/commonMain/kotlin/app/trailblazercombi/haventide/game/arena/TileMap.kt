@file:Suppress("unused")

package app.trailblazercombi.haventide.game.arena

import androidx.compose.foundation.*
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.compositeOver
import androidx.compose.ui.input.pointer.PointerEventType
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.Dp
import app.trailblazercombi.haventide.game.abilities.AbilityTemplate
import app.trailblazercombi.haventide.game.mechanisms.*
import app.trailblazercombi.haventide.resources.UniversalColorizer.*
import app.trailblazercombi.haventide.resources.Palette
import app.trailblazercombi.haventide.resources.Res
import app.trailblazercombi.haventide.resources.UniversalColorizer
import app.trailblazercombi.haventide.resources.ally
import kotlinx.coroutines.flow.MutableStateFlow
import kotlin.math.*
import app.trailblazercombi.haventide.resources.TileStyle.TileSize as tileSize
import app.trailblazercombi.haventide.resources.TileStyle.Padding as tilePadding
import app.trailblazercombi.haventide.resources.TileStyle.CornerRounding as tileCornerRounding
import app.trailblazercombi.haventide.resources.TileStyle.OutlineThickness as tileOutlineThickness

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// POSITION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * This is a position on the map, represented by x and y coordinates.
 */
@Suppress("EqualsOrHashCode")
data class Position(val x: Int, val y: Int) {

    /**
     * Check if this position is equal to another position.
     * Uses the default [Any.equals] method.
     * @param other The [position][Position] you're trying to check against.
     * @return `true` if this position is the same as the other position.
     * Otherwise, returns `false`.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Position) return false
        if (x != other.x) return false
        if (y != other.y) return false
        return true
    }

    override fun toString(): String {
        return "Position [$x, $y]"
    }

    fun toDpX(): Dp {
        return tileSize * x
    }

    fun toDpY(): Dp {
        return tileSize * y
    }

    /**
     * Calculates the distance from this position to another.
     * This distance is in [tiles][TileData], not pixels.
     * Useful for caluclating ability reaches and ranges.
     * @param other The other position you're trying to calculate to.
     * @return The exact distance of a direct straight line
     * between the two positions, in [tiles][TileData].
     */
    fun distanceTo(other: Position): Double {
        val distX = abs(this.x - other.x)
        val distY = abs(this.y - other.y)
        return hypot(distX.toDouble(), distY.toDouble())
    }

    /**
     * Takes the direct line between the two positions.
     * Returns every position the line intersects.
     *
     * __NOTE__: A position here is a [tile][TileData],
     * meaning a square that's __1 tile Ã— 1 tile__ in size,
     * where the position is defined as the center of the tile[TileData]
     * and then spreads __0.5 tiles__ in either direction.
     *
     * @param other The other position you're trying to calculate to.
     * @return A [set][Set] containing all the [tiles][TileData] on the way,
     * __excluding__ [this][Position] and [other][Position].
     */
    // Partially generated by ChatGPT.
    // Tested, vetted and approved by @trailblazercombi.
    // NOTE This is, according to GPT, Bresenham's Line Algorithm
    private fun trajectoryTo(other: Position): List<Position> {
        // Define the result of this method, as a container
        val trajectory = mutableListOf<Position>()

        // Pull X and Y out of the parameters
        var currentX = this.x
        var currentY = this.y
        val destinationX = other.x
        val destinationY = other.y

        // Find out the distance and direction of the line
        val distanceX = abs(destinationX - currentX)
        val distanceY = abs(destinationY - currentY)
        val directionX = if (currentX < destinationX) 1 else -1
        val directionY = if (currentY < destinationY) 1 else -1

        // Find discrepency between the two
        var distanceErr = distanceX - distanceY

        // Cycle: "while not at the end"
        while (currentX != destinationX || currentY != destinationY) {
            // 1. Grab the current position
            val pos = Position(currentX, currentY)

            // 2. If the position isn't the start or the end, add it to the result
            if (pos != this && pos != other) {
                trajectory.add(pos)
            }

            // 3. Find out the next step based on distance
            val doubledDistanceErr = 2 * distanceErr
            if (doubledDistanceErr > -distanceY) {
                distanceErr -= distanceY
                currentX += directionX
            }
            if (doubledDistanceErr < distanceX) {
                distanceErr += distanceX
                currentY += directionY
            }
        }

        // Return the result
        return trajectory
    }

    /**
     * Returns the positions[Position] surrounding this [position][Position]
     * in a specfied circular radius around this tile.
     * @param radius How far to look for the result. Default value is sqrt(2).
     * @return A [Set] of the positions immidiately surrounding [this][Position],
     * __excluding__ [this][Position].
     */
    internal fun surroundings(radius: Double = sqrt(2.toDouble())): Set<Position> {
        if (radius < 1.toDouble()) return emptySet()
        val result = mutableSetOf<Position>()

        val search = round(radius).toInt()
        for (y in -search .. search) {
            val realY = this.y + y
            for (x in -search..search) {
                val realX = this.x + x
                val other = Position(realX, realY)
                if (distanceTo(other) <= radius) {
                    result.add(other)
                }
            }
        }

        result.remove(this)
        return result.toSet()
    }

    /**
     * Returns the positions[Position] surrounding this [position][Position]
     * in a specified circular radius around the tile, but only those that
     * are valid for the specified mechanism on the specified map,
     * and only those that can
     */
    fun traversableSurroundings(
        mapData: TileMapData,
        mechanism: Mechanism,
        radius: Double = sqrt(2.toDouble())
    ): Set<Position> {
        // Create some lists
        val nearby = surroundings(radius).toMutableSet()
        val result = mutableSetOf<Position>()

        // Fill the result based on criteria
        for (nearbyPosition in nearby) {
            val nearbyTile = mapData[nearbyPosition] ?: continue
            if (!nearbyTile.canAddMechanism(mechanism)) continue
            if (!evaluateTrajectoryTraversability(mapData, mechanism, nearbyPosition)) continue
            result.add(nearbyPosition)
        }

        // Filter the result to eliminate lone tiles and unreasonable diagonals in the valid set
        val copyOfResult = result.toSet()
        for (position in copyOfResult) {
            val surrounding = position.surroundings(1.toDouble())
            var removeThisOne = !surrounding.contains(this)
            for (positionNearby in surrounding) {
                if (result.contains(positionNearby)) {
                    removeThisOne = false
                }
            }
            if (removeThisOne) {
                result.remove(position)
            }
        }
        return result.toSet()
    }

    private fun evaluateTrajectoryTraversability(mapData: TileMapData, mechanism: Mechanism, other: Position): Boolean {
        val trajectory = trajectoryTo(other)
        for (position in trajectory) {
            val traversable = mapData[position]?.canTraverse(mechanism) ?: return false
            if (!traversable) return false
        }
        return true
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TILE MAP
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * This is the map data class in all its glory.
 */
class TileMapData(private val turnTable: TurnTable, val gameLoop: GameLoop) {

    // [LATER...] TODO Size does not need to be a property,
    //  and also, read this from file, including the backdrop color.
    val columns = 10; val rows = 10
    val backdropColor = Palette.FullBlack

    private val tiles: MutableMap<Position, TileData?> = mutableMapOf()

    // The question: Will this even need to handle Mechanism movement?
    // The answer:   It does not need to handle Mechanism movement.
    //               The Mechanism directly communicates with the Tiles in question.

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // TILE HIGHLIGHT HANDLING (TileMapData)
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Describes the primary selected tile (yellow).
     * If the yellow tile had an outline before selection (was in availableTiles1),
     * the setters also generates white outline tiles.
     */
    private var selectedTile1: TileData? = null
        set(value) {
            field?.updateClickState(NO_INTERACTIONS_WITH_OUTLINE)
            field = value
            field?.updateClickState(CLICKED_PRIMARY)
            selectedTile2 = null
        }

    /**
     * Describes the secondary selected tile (white).
     * The white tile had to have an outline before selection (was in availableTiles2).
     */
    private var selectedTile2: TileData? = null
        set(value) {
            field?.updateClickState(NO_INTERACTIONS_WITH_OUTLINE)
            field = value
            field?.updateClickState(CLICKED_SECONDARY)
        }

    /**
     * Describes the tertiary selected tile (grey).
     */
    private var selectedTile3: TileData? = null
        set(value) {
            field?.updateClickState(NO_INTERACTIONS_WITH_OUTLINE)
            field = value
            field?.updateClickState(CLICKED_TERTIARY)
        }

    private var preparedAbility: Triple<(Mechanism, TileData) -> Unit, Mechanism, TileData>? = null

    /**
     * A [MutableSet] containing all [tiles][TileData] valid for primary highlight.
     */
    private val availableTiles1 = mutableSetOf<TileData>()

    /**
     * A [MutableSet] containing all [tiles][TileData] valid for secondary highlight.
     */
    private val availableTiles2 = mutableSetOf<TileData>()

    private fun addToAvailableTiles1(tileData: TileData) {
        this.availableTiles1.add(tileData)
        tileData.updateHighlightState(HIGHLIGHT_PRIMARY)
    }

    private fun addToAvailableTiles2(tileData: TileData) {
        this.availableTiles2.add(tileData)
        tileData.updateHighlightState(HIGHLIGHT_SECONDARY)
    }

    private fun clearAvailableTiles1() {
        for (tileData in availableTiles1) {
            tileData.updateHighlightState(NO_INTERACTIONS)
        }
        this.availableTiles1.clear()
    }

    private fun clearAvailableTiles2() {
        for (tileData in availableTiles2) {
            tileData.updateHighlightState(NO_INTERACTIONS)
        }
        this.availableTiles2.clear()
    }

    /* NOTE: Secondary always takes precedence.
         * Reason: when the primary is selected (clicked on a Phoenix),
         * selecting the secondary will always yield a move preview. If the move's target is an ally,
         * previewing a move targeting an ally is always more desirable than selecting another ally.
         * That is, of course, if the ally is targetable (within range and the Phoenix has an ability for that).
         */
    // [GAME LOOP] TODO Make that happen

    private fun currentPlayer(): PlayerInGame {
        return turnTable.currentPlayer()
    }

    private fun localPlayer(): PlayerInGame {
        return gameLoop.localPlayer()
    }

    private fun updateAvailableTiles() {
        // 0. Clear the current highlights
        this.clearAvailableTiles1()
        this.clearAvailableTiles2()

        // 1. Add every tile the localPIG's Phoenixes are standing on
        turnTable.currentPlayer().team.forEach {
            if (it !is PhoenixMechanism) return@forEach
            addToAvailableTiles1(it.parentTile)
        }

        if (selectedTile1 != null) {
            //  Prerequisites: The aforementioned AbilityStack
            val existingTile = selectedTile1 ?: return // If this fails, selectedTile1 is null.
            val localPhoenix = existingTile.getPhoenix() ?: return // this should already be allied only...

            val surroundings = existingTile.position.traversableSurroundings(
                mapData = this,
                mechanism = DummyImmediateEffecter(existingTile),
                radius = localPhoenix.maxAbilityRange(),
            )

            surroundings.forEach {
                val targetTile = this[it] ?: return@forEach
                if (localPhoenix.findFirstAvailableAbility(targetTile) != null) {
                    addToAvailableTiles2(targetTile)
                }
            }
        }
    }

    /**
     * Get [a tile][TileData] from the map definition.
     * @param x The x-coordinate of the [desired tile][TileData].
     * @param y The y-coordiante of the [desired tile][TileData].
     * @return The [desired tile][TileData] if it exists at that [position][Position],
     * or `null` if the requested [position][Position] yielded no [tile][TileData].
     */
    operator fun get(x: Int, y: Int): TileData? {
        return tiles[Position(x, y)]
    }

    /**
     * Get [a tile][TileData] from the map definition.
     * @param position The [position][Position] of the [desired tile][TileData].
     * @return The [desired tile][TileData] if it exists at that [position][Position],
     * or `null` if the requested [position][Position] yielded no [tile][TileData].
     */
    operator fun get(position: Position): TileData? {
        return tiles[position]
    }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // TILE CLICK EVENTS AND PROPAGATION - Start here!
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // This clicks when a Tile is clicked
    internal fun tileClickEvent(tile: TileData) {

        // 1. If there is an ability ready, execute it.
        if (preparedAbility != null && tile === selectedTile2) {
            executeAbility(preparedAbility!!)
            turnTable.nextPlayerTurn()
            updateAvailableTiles()
            return
        }

        // 2. If there is no ability ready, do something else.
        selectedTile3 = null
        // If a yellow tile is selected...
        if (selectedTile1 != null) {
            // ...and you click it, deselect it
            if (tile == selectedTile1) selectedTile1 = null
            // ...and you click a white outlined tile, select that tile too + preview move
            else if (this.availableTiles2.contains(tile)) {
                selectedTile2 = tile
                prepareAbility(
                    template = selectedTile1!!.getPhoenix()!!.findFirstAvailableAbility(selectedTile2!!)!!,
                    doer = selectedTile1!!.getPhoenix()!!,
                    target = selectedTile2!!,
                )
            }
            // ..and you click an unrelated tile, deselect both tiles and see what happens
            else {
                selectedTile1 = null
                selectedTile2 = null
                tileClickEvent(tile)
            }
        // Else, if no tile is selected, and you click a yellow outlined tile
        } else if (availableTiles1.contains(tile)) {
            selectedTile1 = tile
            selectedTile2 = null
        // Else, if not tile is selected and you click an unmarked tile
        } else {
            selectedTile1 = null
            selectedTile2 = null
            selectedTile3 = tile
        }
        this.updateAvailableTiles()
    }

    private fun prepareAbility(template: AbilityTemplate, doer: Mechanism, target: TileData) {
        this.preparedAbility = Triple(template.execution, doer, target)
    }

    private fun executeAbility(triple: Triple<(Mechanism, TileData) -> Unit, Mechanism, TileData>) {
        executeAbility(triple.first, triple.second, triple.third)
    }

    private fun executeAbility(execution: (Mechanism, TileData) -> Unit, doer: Mechanism, target: TileData) {
        execution(doer, target)
        selectedTile1 = null
        selectedTile2 = null
        selectedTile3 = null
    }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // THE FORSAKEN INIT BLOCK
        // Moved here because NullPointerException when trying to call fields below it...
        // Ghhhhhhh...
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    init {
        // [LATER...] TODO Read from a file instead
        for (y in 0 until rows) {
            for (x in 0 until columns) {
                val position = Position(x, y)
//                if (x % 2 == 0 && y % 4 == 0) tiles[position] = null
                tiles[position] = TileData(this, position)
            }
        }
        var i = 0 // [MAPS] FIXME this is so janky
        turnTable.allPlayers().forEach {
            it.addRoster(get(3, 3 * i)!!, get(4, 3 * i)!!, get(5, 3 * i)!!)
            i++
        }
        updateAvailableTiles()
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TILE DATA
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * This is the class representing a single tile on the map,
 * including its content (Mechanisms)
 */
class TileData(
    // BASIC DATA
    val parentMap: TileMapData,
    internal val position: Position,
    private val mechanismStack: MutableSet<Mechanism> = mutableSetOf(),

    // COMPOSE STATES: COLORIZERS
    internal var clickStateColorizer: MutableStateFlow<UniversalColorizer> = MutableStateFlow(NO_INTERACTIONS_WITH_OUTLINE),
    internal var highlightStateColorizer: MutableStateFlow<UniversalColorizer> = MutableStateFlow(NO_INTERACTIONS),
    internal var hoverStateColorizer: MutableStateFlow<UniversalColorizer> = MutableStateFlow(NO_INTERACTIONS)
    // [LATER...] TODO Mechanism stack colorizer(s)
) {
    // COMPOSE STATES: MECHANISM STACK
    val mechanismStackState = MutableStateFlow(mechanismStack.toSet())
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // MECHANISM ADDITION, REMOVAL AND CHECKS (TileData)
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //  About the CHECKING SYSTEM:
    //  Tile:    All calls for mechanism operations check themselves
    //  TileMap: All calls for mechanism operations check themselves
    //  Mechanism:
    //      Invokers:   "Check, cast, call" on TileMap MechanismStack
    //      Handlers:   Do not perform any checking themselves
    //      destruct(): Performs a full check for destruction
    //                  but thorws an exception if the check failed
    //      move():     Performs a check for "is MovementEnabled",
    //                  and throws an exception if the check failed
    //                  (performs no other checks)

    /**
     * Runs [checks][canAddMechanism] on the specified [mechanism][Mechanism].
     * If [all checks][canAddMechanism] are passed, adds the [mechanism][Mechanism] to this tile.
     *
     * @param mechanism The [mechanism][Mechanism] in question.
     */
    fun addMechanism(mechanism: Mechanism) {
        if (canAddMechanism(mechanism)) {
            mechanismStack.add(mechanism)
            updateMechanismStackState()
        }
    }

    /**
     * Runs [checks][canAddMechanism] on the specified [mechanism][Mechanism].
     * If [all checks][canAddMechanism] are passed, removes the [mechanism][Mechanism] from this tile.
     *
     * @param mechanism The [mechanism][Mechanism] in question.
     */
    fun removeMechanism(mechanism: Mechanism) {
        if (canRemoveMechanism(mechanism)) {
            mechanismStack.remove(mechanism)
            updateMechanismStackState()
        }
    }

    /**
     * Checks if the specified [mechanism][Mechanism] can be added to this tile.
     * @param mechanism The [mechanism][Mechanism] in question.
     * @return `true` if the [mechanism][Mechanism] can be added,
     * `false` if the [mechanism][Mechanism] is a duplicate of one already on this tile,
     * or if any of the [mechanisms][Mechanism] on this tile veto the operation.
     */
    @Suppress("MemberVisibilityCanBePrivate")
    fun canAddMechanism(mechanism: Mechanism): Boolean {
//        // 0: Do not check ImmediateEffecters, thank you :)
//        if (mechanism is ImmediateEffecter && mechanism !is DummyImmediateEffecter) throw IllegalArgumentException(
//            "Cannot check for ImmediateEffecters. " +
//                    "It would immediately explode and leave behind consequences. " +
//                    "Even if the check failed."
//        )
        // 1: Check if it's duplicate
        if (mechanismStack.contains(mechanism)) return false
        // 2: Check if it's compatible with the current mechanism stack
        for (mechie in mechanismStack) {
            if (mechie.vetoTilemateAddition(mechanism)) return false
        }
        // All checks passed: Can move mechanism
        return true
    }

    /**
     * Checks if the specified [mechanism][Mechanism] can traverse through this tile.
     * @param mechanism The [mechanism][Mechanism] in question.
     * @return `true` if the [mechanism][Mechanism] can do so,
     * `false` if any of the [mechanisms][Mechanism] on this tile veto the operation.
     */
    fun canTraverse(mechanism: Mechanism): Boolean {
        for (mechie in mechanismStack) {
            if (mechie.vetoTraversal(mechanism)) return false
        }
        return true
    }

    /**
     * Checks if the specified [mechanism][Mechanism] can be removed from this tile.
     * @param mechanism The [mechanism][Mechanism] in question.
     * @return `true` if the [mechanism][Mechanism] can be removed,
     * `false` if the [mechanism][Mechanism] doesn't exist on this tile,
     * or if any of the other [mechanisms][Mechanism] on this tile veto the operation.
     */
    @Suppress("MemberVisibilityCanBePrivate")
    fun canRemoveMechanism(mechanism: Mechanism): Boolean {
        // 1: Check if it's here
        if (mechanism is ImmediateEffecter) return true // Special case, these need to be always destructed
        if (!mechanismStack.contains(mechanism)) return false

        // 2: Check if it's not necessary for another mechanism to exist
        for (mechie in mechanismStack) {
            if (mechie === mechanism) continue
            if (mechie.vetoTilemateRemoval(mechanism)) return false
        }

        // All checks passed: Can remove mechanism
        return true
    }

    fun getPhoenix(): PhoenixMechanism? {
        this.mechanismStack.forEach { if (it is PhoenixMechanism) return it }
        return null
    }

    fun getMechanismStack(): Set<Mechanism> {
        return mechanismStack.toSet()
    }

    private fun updateMechanismStackState() {
        mechanismStackState.value = mechanismStack.toSet()
    }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // CLICK STATE PROPAGATION AND HANDLING (TileData)
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Send the click event from [the user][ComposableTile] upwards, to the parent [map][TileMapData].
     * The [map][TileMapData] handles the rest.
     */
    fun tileClickEvent() {
        parentMap.tileClickEvent(this)
    }

    /**
     * Update the __click state__ of the Composable Tile.
     * This dictates the base fill and outline color.
     * @param clickStateColorizer The new color of this state, as defined by [UniversalColorizer]
     */
    internal fun updateClickState(clickStateColorizer: UniversalColorizer) {
        this.clickStateColorizer.value = clickStateColorizer
    }

    /**
     * Update the __highlight__ state of the Composable Tile.
     * This dictates the outline color, for tiles which would actually be useful to click.
     * @param highlightStateColorizer The new color of this state, as defined by [UniversalColorizer]
     */
    internal fun updateHighlightState(highlightStateColorizer: UniversalColorizer) {
        this.highlightStateColorizer.value = highlightStateColorizer
    }

    /**
     * Update the __hover__ state of the Composable Tile.
     * This dictates the fill and outline glass for pointer devices.
     * @param hoverStateColorizer The new color of this state, as defined by [UniversalColorizer]
     */
    internal fun updateHoverState(hoverStateColorizer: UniversalColorizer) {
        this.hoverStateColorizer.value = hoverStateColorizer
    }

    /**
     * Find and return all [teams][Team] that have a presence on this tile.
     * [NeutralFaction] is considered to be always present.
     */
    fun findTeams(): Set<Team> {
        val result: MutableSet<Team> = mutableSetOf()
        this.mechanismStack.forEach {
            if (it.teamAffiliation != null) result.add(it.teamAffiliation)
        }
        return result.toSet()
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMPOSABLES
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * This is the UI layer of [TileMapData].
 */
@Composable
fun ComposableTileMap(mapData: TileMapData, modifier: Modifier = Modifier) {
    // Keep the states here
    val scrollStateX = rememberScrollState()
    val scrollStateY = rememberScrollState()

    // The TileMap's background.
    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
            .fillMaxSize()
            .background(mapData.backdropColor)
            .scrolling(scrollStateX, scrollStateY)
    ) {
        Column {
            for (y in 0 until mapData.rows) {
                Row {
                    for (x in 0 until mapData.columns) {
                        // Starting from this point, we have tile coordinates.
                        ComposableTile(mapData[x, y])
                    }
                }
            }
        }
    }
}

/**
 * This is the UI layer of [TileData].
 */
@Composable
private fun ComposableTile(tileData: TileData? = null, modifier: Modifier = Modifier) {
    if (tileData != null) {
        val clickState by tileData.clickStateColorizer.collectAsState()
        val highlightState by tileData.highlightStateColorizer.collectAsState()
        val hoverState by tileData.hoverStateColorizer.collectAsState()
        val mechanisms by tileData.mechanismStackState.collectAsState()

        Box( // Full tile scope
            contentAlignment = Alignment.Center,
            modifier = modifier
                .width(tileSize)
                .height(tileSize)
                .clickable(
                    indication = null,
                    interactionSource = remember { MutableInteractionSource() },
                    onClick = {
                        tileData.tileClickEvent()
                    }
                )
                .handleHover(
                    onEnter = {
                        tileData.updateHoverState(HOVER_GLASS)
                    },
                    onExit = {
                        tileData.updateHoverState(NO_INTERACTIONS)
                    }
                )
        ) {
            Box( // The rendered outline
                modifier = Modifier
                    .size(tileSize - tilePadding)
                    .clip(RoundedCornerShape(tileCornerRounding))
                    .border(
                        tileOutlineThickness,
                        hoverState.outlineColor
                            .compositeOver(highlightState.outlineColor)
                            .compositeOver(clickState.outlineColor),
                        RoundedCornerShape(tileCornerRounding))
                    .background(hoverState.fillColor
                        .compositeOver(highlightState.fillColor)
                        .compositeOver(clickState.fillColor)
                    )
            )
            ComposableMechanismStack(mechanisms, modifier.align(Alignment.Center))
        }
    } else {
        Spacer(modifier.width(tileSize).height(tileSize))
    }
}

/**
 * The [tile][TileData]'s current [Mechanism Stack][TileData.mechanismStack].
 */
@Composable
fun ComposableMechanismStack(mechanisms: Set<Mechanism>, modifier: Modifier = Modifier) {
    Box (
        contentAlignment = Alignment.Center,
        modifier = modifier
        .size(tileSize)
    ) {
        mechanisms.forEach {
            ComposableMechanism(it, Modifier.align(Alignment.Center))
        }
    }
    // [LATER...] TODO Smarter approach, because this will look so stupid
}

/**
 * An extension function for [Modifier].
 * It is used to handle hover inputs when a pointer is used, such as a mouse or stylus hover.
 */
@Composable
private fun Modifier.handleHover(onEnter: () -> Unit = {}, onExit: () -> Unit = {}): Modifier = pointerInput(Unit) {
    awaitPointerEventScope {
        while (true) {
            val event = awaitPointerEvent()
            when (event.type) {
                PointerEventType.Enter -> onEnter()
                PointerEventType.Exit -> onExit()
                else -> {}
            }
        }
    }
}

/**
 * An extension function that could, presumably, in the future, hanlde smooth scrolling,
 * including diagonal.
 */
@Composable
private fun Modifier.scrolling(scrollStateX: ScrollState, scrollStateY: ScrollState): Modifier {
    return this
        .horizontalScroll(scrollStateX)
        .verticalScroll(scrollStateY)
    // [LATER...] TODO smooth diagonal scrolling (low priority)
}
