package app.trailblazercombi.haventide.game2.data.tilemap

import androidx.compose.ui.unit.Dp
import app.trailblazercombi.haventide.game2.data.tilemap.mechanisms.Mechanism
import app.trailblazercombi.haventide.resources.TileStyle.TileSize
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.round
import kotlin.math.sqrt

/**
 * This is a position on the map, represented by x and y coordinates.
 */
@Suppress("EqualsOrHashCode")
data class Position(val x: Int, val y: Int) {

    /**
     * Check if this position is equal to another position.
     * Uses the default [Any.equals] method.
     * @param other The [position][Position] you're trying to check against.
     * @return `true` if this position is the same as the other position.
     * Otherwise, returns `false`.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Position) return false
        if (x != other.x) return false
        if (y != other.y) return false
        return true
    }

    override fun toString(): String {
        return "Position [$x, $y]"
    }

    /**
     * Extract the position to [density pixels][Dp], taking into account [TileSize].
     */
    fun toDpX(): Dp {
        return TileSize * x
    }

    /**
     * Extract the position to [density pixels][Dp], taking into account [TileSize].
     */
    fun toDpY(): Dp {
        return TileSize * y
    }

    /**
     * Calculates the distance from this position to another.
     * This distance is in [tiles][TileData], not pixels.
     * Useful for caluclating ability reaches and ranges.
     * @param other The other position you're trying to calculate to.
     * @return The exact distance of a direct straight line
     * between the two positions, in [tiles][TileData].
     */
    fun distanceTo(other: Position): Double {
        val distX = abs(this.x - other.x)
        val distY = abs(this.y - other.y)
        return hypot(distX.toDouble(), distY.toDouble())
    }

    /**
     * Takes the direct line between the two positions.
     * Returns every position the line intersects.
     *
     * __NOTE__: A position here is a [tile][TileData],
     * meaning a square that's __1 tile Ã— 1 tile__ in size,
     * where the position is defined as the center of the tile[TileData]
     * and then spreads __0.5 tiles__ in either direction.
     *
     * @param other The other position you're trying to calculate to.
     * @return A [set][Set] containing all the [tiles][TileData] on the way,
     * __excluding__ [this][Position] and [other][Position].
     */
    // Partially generated by ChatGPT.
    // Tested, vetted and approved by @trailblazercombi.
    // NOTE This is, according to GPT, Bresenham's Line Algorithm
    fun trajectoryTo(other: Position): List<Position> {
        // Define the result of this method, as a container
        val trajectory = mutableListOf<Position>()

        // Pull X and Y out of the parameters
        var currentX = this.x
        var currentY = this.y
        val destinationX = other.x
        val destinationY = other.y

        // Find out the distance and direction of the line
        val distanceX = abs(destinationX - currentX)
        val distanceY = abs(destinationY - currentY)
        val directionX = if (currentX < destinationX) 1 else -1
        val directionY = if (currentY < destinationY) 1 else -1

        // Find discrepency between the two
        var distanceErr = distanceX - distanceY

        // Cycle: "while not at the end"
        while (currentX != destinationX || currentY != destinationY) {
            // 1. Grab the current position
            val pos = Position(currentX, currentY)

            // 2. If the position isn't the start or the end, add it to the result
            if (pos != this && pos != other) {
                trajectory.add(pos)
            }

            // 3. Find out the next step based on distance
            val doubledDistanceErr = 2 * distanceErr
            if (doubledDistanceErr > -distanceY) {
                distanceErr -= distanceY
                currentX += directionX
            }
            if (doubledDistanceErr < distanceX) {
                distanceErr += distanceX
                currentY += directionY
            }
        }

        // Return the result
        return trajectory
    }

    /**
     * Returns the positions[Position] surrounding this [position][Position]
     * in a specfied circular radius around this tile.
     * @param radius How far to look for the result. Default value is sqrt(2).
     * @return A [Set] of the positions immidiately surrounding [this][Position],
     * __excluding__ [this][Position].
     */
    fun surroundings(radius: Double = sqrt(2.toDouble())): Set<Position> {
        if (radius < 1.toDouble()) return emptySet()
        val result = mutableSetOf<Position>()

        val search = round(radius).toInt()
        for (y in -search .. search) {
            val realY = this.y + y
            for (x in -search..search) {
                val realX = this.x + x
                val other = Position(realX, realY)
                if (distanceTo(other) <= radius) {
                    result.add(other)
                }
            }
        }

        result.remove(this)
        return result.toSet()
    }

    /**
     * Returns the positions[Position] surrounding this [position][Position]
     * in a specified circular radius around the tile, but only those that
     * are valid for the specified mechanism on the specified map,
     * and only those that can
     */
    fun traversableSurroundings(
        mapData: TileMapData,
        mechanism: Mechanism,
        radius: Double = sqrt(2.toDouble())
    ): Set<Position> {
        // Create some lists
        val nearby = surroundings(radius).toMutableSet()
        val result = mutableSetOf<Position>()

        // Fill the result based on criteria
        for (nearbyPosition in nearby) {
            val nearbyTile = mapData[nearbyPosition] ?: continue
            if (!nearbyTile.canAddMechanism(mechanism)) continue
            if (!evaluateTrajectoryTraversability(mapData, mechanism, nearbyPosition)) continue
            result.add(nearbyPosition)
        }

        // Filter the result to eliminate lone tiles and unreasonable diagonals in the valid set
        val copyOfResult = result.toSet()
        for (position in copyOfResult) {
            val surrounding = position.surroundings(1.toDouble())
            var removeThisOne = !surrounding.contains(this)
            for (positionNearby in surrounding) {
                if (result.contains(positionNearby)) {
                    removeThisOne = false
                }
            }
            if (removeThisOne) {
                result.remove(position)
            }
        }
        return result.toSet()
    }

    private fun evaluateTrajectoryTraversability(mapData: TileMapData, mechanism: Mechanism, other: Position): Boolean {
        val trajectory = trajectoryTo(other)
        for (position in trajectory) {
            val traversable = mapData[position]?.canTraverse(mechanism) ?: return false
            if (!traversable) return false
        }
        return true
    }
}
