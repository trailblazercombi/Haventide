package app.trailblazercombi.haventide.game2.viewModel

import app.trailblazercombi.haventide.game2.data.turntable.Die
import app.trailblazercombi.haventide.resources.DieType
import kotlinx.coroutines.flow.MutableStateFlow

/**
 * A supporting class that maps highlight states to individual Dice.
 * The @Composable [app.trailblazercombi.haventide.game2.jetpack.gamescreen.panels.components.ComposableDie]
 * drinks StateFlows generated by this as States.
 */
class DiceStateMap(listOfDice: List<Die>) {
    private val stateMap: Map<Die, Pair<MutableStateFlow<Boolean>, MutableStateFlow<Boolean>>>

    init {
        val result = mutableMapOf<Die, Pair<MutableStateFlow<Boolean>, MutableStateFlow<Boolean>>>()
        listOfDice.forEach { result[it] = (MutableStateFlow(false) to MutableStateFlow(false)) }
        stateMap = result.toMap()
    }

    /**
     * Return the current aligned [MutableStateFlow] of the requested die.
     */
    fun alignedStateOf(die: Die) = stateMap[die]?.first

    /**
     * Return the current selected [MutableStateFlow] of the requested die.
     */
    fun selectedStateOf(die: Die) = stateMap[die]?.second

    /**
     * Set all dice in the StateMap of a specific type to highlight on alignment.
     *
     * __NOTE:__ This one automatically resets aligned selection from before.
     */
    fun setAligned(type: DieType?) {
        resetAligned()
        if (type == null) return
        stateMap.keys.forEach { die -> if (die.type == type) stateMap[die]?.also { it.first.value = true } }
    }

    /**
     * Select dice in the StateMap (set their selected state).
     *
     * __NOTE:__ This one does not automatically reset anything.
     */
    fun setSelected(vararg dice: Die) {
        dice.forEach { die -> stateMap[die]?.let { it.second.value = true } }
    }

    /**
     * Reset all dice selected state to false.
     */
    fun resetSelected() = stateMap.values.forEach { it.second.value = false }

    /**
     * Reset all dice aligned state to false.
     */
    fun resetAligned() = stateMap.values.forEach { it.first.value = false }

    /**
     * @return The actual count of all selected aligned dice.
     */
    fun countAlignedSelected() = stateMap.keys.count { stateMap[it]!!.first.value && stateMap[it]!!.second.value }

    /**
     * @return The actual count of all scattered selected dice.
     */
    fun countScatteredSelected() = stateMap.keys.count { !(stateMap[it]!!.first.value) && stateMap[it]!!.second.value }

    /**
     * @return ALl tiles that are currently selected.
     */
    fun getAllSelectedDice() = stateMap.filterValues { it.second.value }.keys.toList()

    /**
     * @return All keys of the current StateMap as new [List].
     */
    fun getKeys() = stateMap.keys.toList()
}
